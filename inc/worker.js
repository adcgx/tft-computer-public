function Z(e,t){const o={memory:t};return WebAssembly.instantiate(e,{env:o}).then((e=>e.module?e.instance:e)).catch((e=>{throw console.error("WASM instantiate error:",e),e}))}let ee;self.onmessage=async function(e){const{type:t,data:o}=e.data;if("init"===t)console.log("Worker started with data:",e.data),memory=new WebAssembly.Memory({initial:10,maximum:10}),ee=Z(o.compiled_module,memory).then((e=>{ee=e,console.log("Module initialized:",e),new Uint8Array(ee.exports.memory.buffer).set(o.subsets_memory,ee.exports.get_subsets()),ee.exports.set_subsets_count(o.subsets_count);let t=ee.exports.get_result_count();const r=new Uint8Array(ee.exports.memory.buffer);self.postMessage({memory_buffer:r,results_count:t})})).catch((e=>{console.error("WASM instantiate error:",e)}));else if("init_mem"===t)memory=new WebAssembly.Memory({initial:10,maximum:10}),ee=Z(o.compiled_module,memory).then((e=>{ee=e,new Uint8Array(ee.exports.memory.buffer).set(o.memory_buffer),console.log("Module initialized:",e)})).catch((e=>{console.error("WASM instantiate error:",e)}));else if("run"===t){Boolean(ee&&"function"==typeof ee.then)&&await ee;let e=o.thread_idx,t=o.thread_count;console.log("starting thread:",e,t),ee.exports.run(e,t);let n=[];for(var r=ee.exports.get_result_count(),s=0;s<r;++s)n.push({comp:ee.exports.get_result_comp(s),value:ee.exports.get_result_value(s)});self.postMessage({results:n,thread_idx:e})}};